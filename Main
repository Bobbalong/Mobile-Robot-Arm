//Serial is input to serialString, stringComplete true when \n received
String serialString1 = "";
boolean stringComplete = false;
//Base Motor
const int BmotorFwd = 2;
const int BmotorRev = 3;
int BmotorfState = 0;
int BmotorrState = 0;
unsigned long BmotorMillis;
//Joint Motor 1
const int m1Fwd = 4;
const int m1Rev = 5;
int m1fState = 0;
int m1rState = 0;
unsigned long m1Millis;
//Joint Motor 2
const int m2Fwd = 6;
const int m2Rev = 7;
int m2fState = 0;
int m2rState = 0;
unsigned long m2Millis;
//Wrist Motor 3
const int m3Fwd = 8;
const int m3Rev = 9;
int m3fState = 0;
int m3rState = 0;
unsigned long m3Millis;
//Gripper Motor 4
const int m4Fwd = 10;
const int m4Rev = 11;
//Left Wheel Motor
const int leftWmotorFwd = 22;
const int leftWmotorRev = 23;
unsigned long lWmFMillis;
unsigned long lWmRMillis;
int lWmFState = 0;
int lWmRState = 0;
//Right Wheel Motor
const int rightWmotorFwd  = 24;
const int rightWmotorRev  = 25;
unsigned long rWmFMillis;
unsigned long rWmRMillis;
int rWmFState = 0;
int rWmRState = 0;
//LED
const int LEDpin  = 12;
int LEDstate = 0;
unsigned long LEDMillis;
int BlinkInterval = 30;
//Gripper
int gripPos = 0;
int gripTime = 850;
//Motor Run time
int burstTime  = 1000;
int mStep = 250;
//Commands
int Command;
const int commandSig[] = {120, 50, 46, 48, 49, 51, 52, 55, 54, 57, 53, 56, 43, 45, 113, 97, 101, 100, 119, 115, 116, 99, 122};
const int commandQty = 22;
//=======================================================================================================================================
void spin180r() {
  digitalWrite(leftWmotorRev, HIGH);
  digitalWrite(rightWmotorFwd, HIGH);
  delay(2375);
  digitalWrite(leftWmotorRev, LOW);
  digitalWrite(rightWmotorFwd, LOW);
}
//=======================================================================================================================================
void setup() {
  Serial.begin(9600);
  pinMode(BmotorFwd, OUTPUT);
  pinMode(BmotorRev, OUTPUT);
  pinMode(m1Fwd, OUTPUT);
  pinMode(m1Rev, OUTPUT);
  pinMode(m2Fwd, OUTPUT);
  pinMode(m2Rev, OUTPUT);
  pinMode(m3Fwd, OUTPUT);
  pinMode(m3Rev, OUTPUT);
  pinMode(m4Fwd, OUTPUT);
  pinMode(m4Rev, OUTPUT);
  pinMode(leftWmotorFwd, OUTPUT);
  pinMode(leftWmotorRev, OUTPUT);
  pinMode(rightWmotorFwd, OUTPUT);
  pinMode(rightWmotorRev, OUTPUT);
  pinMode(LEDpin, OUTPUT);
  while (! Serial) {
    ;
  }
//-----Splash
  Serial.println("Arm' Control."); delay(1500);
  Serial.println("Ready.");
}
//=======================================================================================================================================
void serialEvent() {
//Serial catcher. If there's serial available it will be added to a string, until
//a newline is received. After a newline the string state will be active. Then
//the string is complete and loop() begins. I have included a limiter() as a 
//precaution.
  while (Serial.available() > 0) {
    char inChar = (char)Serial.read();
    if (inChar == '\n') {
      stringComplete = true;
    }
    else
      serialString1 += inChar;
    limiter();
  }
}
//=======================================================================================================================================
void loop() {
//This will assess a string passed from the serial.event(). First the string is
//printed. The commandCheck() will compare it to a list of know strings, if a
//match is found a command will be performed. The limiter within the 'if' is a 
//precaution. After the string and limiter have been used the string contents are 
//cleared and state deactivated. If nothing else the loop with run the limiter.
  if (stringComplete) {
    Serial.print(serialString1);
    Serial.println(": ");
    commandCheck();
    limiter();
    serialString1 = "";
    stringComplete = false;
  }
  limiter();
}
//=======================================================================================================================================
void limiter() {
//This function will check for active states and deactivate them if a 
//predetermined time has passed. Some states can be stacked, if the time for a
//stacked state is reached no deactivation is perfomed and the stack is reduced.

  unsigned long currentMillis = millis();

  //------Time active check for Base Motor, Forward. Stack
  if ((BmotorfState > 1) && (currentMillis - BmotorMillis >= burstTime)) {
    BmotorfState--;
    BmotorMillis =  millis();
    Serial.println("Tick, Base Motor Forward.");
  }
  //------Time active check for Base Motor, Forward. End
  if ((BmotorfState == 1) && (currentMillis - BmotorMillis >= burstTime)) {
    digitalWrite(BmotorFwd, LOW);
    BmotorfState--;
    Serial.println("Stopped, Base Motor Forward.");
  }
  //------Time active check for Base Motor, Reverse. Stack
  if ((BmotorrState > 1) && (currentMillis - BmotorMillis >= burstTime)) {
    BmotorrState--;
    BmotorMillis =  millis();
    Serial.println("Tick, Base Motor Reverse.");
  }
  //------Time active check for Base Motor, Reverse. End
  if ((BmotorrState == 1) && (currentMillis - BmotorMillis >= burstTime)) {
    digitalWrite(BmotorRev, LOW);
    BmotorrState--;
    Serial.println("Stopped, Base Motor Reverse.");
  }
  //------Time active check for Motor 1, Forward. Stack
  if ((m1fState > 1) && (currentMillis - m1Millis >= burstTime)) {
    m1fState--;
    m1Millis =  millis();
    Serial.println("Tick, Motor 1 Forward.");
  }
  //------Time active check for Motor 1, Forward. End
  if ((m1fState == 1) && (currentMillis - m1Millis >= burstTime)) {
    digitalWrite(m1Fwd, LOW);
    m1fState--;
    Serial.println("Stopped, Motor 1 Forward.");
  }
  //------Time active check for Motor 1, Reverse. Stack
  if ((m1rState > 1) && (currentMillis - m1Millis >= burstTime)) {
    m1rState--;
    m1Millis =  millis();
    Serial.println("Tick, Motor 1 Reverse.");
  }
  //------Time active check for Motor 1, Reverse. End
  if ((m1rState == 1) && (currentMillis - m1Millis >= burstTime)) {
    digitalWrite(m1Rev, LOW);
    m1rState--;
    Serial.println("Stopped, Motor 1 Reverse.");
  }
  //------Time active check for Motor 2, Forward. Stack
  if ((m2fState > 1) && (currentMillis - m2Millis >= burstTime)) {
    m2fState--;
    m2Millis =  millis();
    Serial.println("Tick, Motor 2 Forward.");
  }
  //------Time active check for Motor 2, Forward. End
  if ((m2fState == 1) && (currentMillis - m2Millis >= burstTime)) {
    digitalWrite(m2Fwd, LOW);
    m2fState--;
    Serial.println("Stopped, Motor 2 Forward.");
  }
  //------Time active check for Motor 2, Reverse. Stack
  if ((m2rState > 1) && (currentMillis - m2Millis >= burstTime)) {
    m2rState--;
    m2Millis =  millis();
    Serial.println("Tick, Motor 2 Reverse.");
  }
  //------Time active check for Motor 2, Reverse. End
  if ((m2rState == 1) && (currentMillis - m2Millis >= burstTime)) {
    digitalWrite(m2Rev, LOW);
    m2rState--;
    Serial.println("Stopped, Motor 2 Reverse.");
  }
  //------Time active check for Motor 3, Forward. Stack
  if ((m3fState > 1) && (currentMillis - m3Millis >= burstTime)) {
    m3fState--;
    m3Millis =  millis();
    Serial.println("Tick, Motor 3 Forward.");
  }
  //------Time active check for Motor 3, Forward. End
  if ((m3fState == 1) && (currentMillis - m3Millis >= burstTime)) {
    digitalWrite(m3Fwd, LOW);
    m3fState--;
    Serial.println("Stopped, Motor 3 Forward.");
  }
  //------Time active check for Motor 3, Reverse. Stack
  if ((m3rState > 1) && (currentMillis - m3Millis >= burstTime)) {
    m3rState--;
    m3Millis =  millis();
    Serial.println("Tick, Motor 3 Reverse.");
  }
  //------Time active check for Motor 3, Reverse. End
  if ((m3rState == 1) && (currentMillis - m3Millis >= burstTime)) {
    digitalWrite(m3Rev, LOW);
    m3rState--;
    Serial.println("Stopped, Motor 3 Reverse.");
  }
  //------Time active check for Left Wheel Motor, Forward. Stack
  if ((lWmFState > 1) && (currentMillis - lWmFMillis >= burstTime)) {
    lWmFState--;
    lWmFMillis =  millis();
    Serial.println("Tick, Left Wheel Motor Forward.");
  }
  //------Time active check for Left Wheel Motor, Forward. End
  if ((lWmFState == 1) && (currentMillis - lWmFMillis >= burstTime)) {
    digitalWrite(leftWmotorFwd, LOW);
    lWmFState--;
    Serial.println("Stopped, Left Wheel Motor Forward.");
  }
  //------Time active check for Right Wheel Motor, Forward. Stack
  if ((rWmFState > 1) && (currentMillis - rWmFMillis >= burstTime)) {
    rWmFState--;
    rWmFMillis =  millis();
    Serial.println("Tick, Right Wheel Motor Forward.");
  }
  //------Time active check for Right Wheel Motor, Forward. End
  if ((rWmFState == 1) && (currentMillis - rWmFMillis >= burstTime)) {
    digitalWrite(rightWmotorFwd, LOW);
    rWmFState--;
    Serial.println("Stopped, Right Wheel Motor Forward.");
  }
  //------Time active check for Left Wheel Motor, Reverse. Stack
  if ((lWmRState > 1) && (currentMillis - lWmRMillis >= burstTime)) {
    lWmRState--;
    lWmRMillis =  millis();
    Serial.println("Tick, Left Wheel Motor Reverse.");
  }
  //------Time active check for Left Wheel Motor, Reverse. End
  if ((lWmRState == 1) && (currentMillis - lWmRMillis >= burstTime)) {
    digitalWrite(leftWmotorRev, LOW);
    lWmRState--;
    Serial.println("Stopped, Left Wheel Motor Reverse.");
  }
  //------Time active check for Right Wheel Motor, Reverse. Stack
  if ((rWmRState > 1) && (currentMillis - rWmRMillis >= burstTime)) {
    rWmRState--;
    rWmRMillis =  millis();
    Serial.println("Tick, Right Wheel Motor Reverse.");
  }
  //------Time active check for Right Wheel Motor, Reverse. End
  if ((rWmRState == 1) && (currentMillis - rWmRMillis >= burstTime)) {
    digitalWrite(rightWmotorRev, LOW);
    rWmRState--;
    Serial.println("Stopped, Right Wheel Motor Reverse.");
  }
}
//=========================================================================================
void commandCheck() {
  for (int x = 0; x < commandQty; x++) {
    if (serialString1 == "state")
    {
      Serial.print(BmotorfState);
      Serial.print(BmotorrState);
      Serial.print(m1fState);
      Serial.print(m1rState);
      Serial.print(m2fState);
      Serial.print(m2rState);
      Serial.print(m3fState);
      Serial.println(m3rState);
    }
    else if (serialString1[x] == 'w')
    {
      if (lWmRState == 0) {
        Serial.println("Command: Full Forward.");
        digitalWrite(leftWmotorFwd, HIGH);
        digitalWrite(rightWmotorFwd, HIGH);
        lWmFMillis = millis();
        rWmFMillis = millis();
        lWmFState++;
        rWmFState++;
      }
      else if (lWmRState > 0) {
        Serial.println("DENIED: Full Forward.");
      }
    }
    else if (serialString1[x] == 's')
    {
      if (lWmFState == 0) {
        Serial.println("Command: Full Reverse.");
        digitalWrite(leftWmotorRev, HIGH);
        digitalWrite(rightWmotorRev, HIGH);
        lWmRMillis = millis();
        rWmRMillis = millis();
        lWmRState++;
        rWmRState++;
      }
      else if (lWmFState > 0) {
        Serial.println("DENIED: Full Reverse.");
      }
    }
    else if (serialString1[x] == 'q')
    {
      if (rWmRState == 0) {
        Serial.println("Command: Right Wheel Forward");
        digitalWrite(rightWmotorFwd, HIGH);
        rWmFMillis = millis();
        rWmFState++;
      }
    }
    else if (serialString1[x] == 'a')
    {
      if (rWmFState == 0) {
        Serial.println("Command: Right Wheel Reverse");
        digitalWrite(rightWmotorRev, HIGH);
        rWmRMillis = millis();
        rWmRState++;
      }
    }
    else if (serialString1[x] == 'e')
    {
      if (lWmRState == 0) {
        Serial.println("Command: Left Wheel Forward");
        digitalWrite(leftWmotorFwd, HIGH);
        lWmFMillis = millis();
        lWmFState++;
      }
    }
    else if (serialString1[x] == 'd')
    {
      if (lWmFState == 0) {
        Serial.println("Command: Left Wheel Reverse");
        digitalWrite(leftWmotorRev, HIGH);
        lWmRMillis = millis();
        lWmRState++;
      }
    }
    else if (serialString1[x] == '0')
    {
      if (LEDstate == 0) {
        Serial.println("Spotlight On. ");
        digitalWrite(LEDpin, HIGH);
        LEDstate = 1;
      }
      else if (LEDstate == 1) {
        Serial.println("Spotlight Off. ");
        digitalWrite(LEDpin, LOW);
        LEDstate = 0;
    }
    }
    else if (serialString1[x] == '1')
    {
      if (BmotorrState == 0) {
        Serial.println("Command: Rotating base, Left");
        digitalWrite(BmotorFwd, HIGH);
        BmotorMillis = millis();
        BmotorfState++;
      }
    }
    else if (serialString1[x] == '3')
    {
      if (BmotorfState == 0) {
        Serial.println("Rotating base, Right");
        digitalWrite(BmotorRev, HIGH);
        BmotorMillis = millis();
        BmotorrState++;
      }
    }
    else if (serialString1[x] == '7')
    {
      if (m1rState == 0) {
        Serial.println("Command: Motor 1, Forward.");
        digitalWrite(m1Fwd, HIGH);
        m1Millis = millis();
        m1fState++;
      }
    }
    else if (serialString1[x] == '4')
    {
      if (m1fState == 0) {
        Serial.println("Command: Motor 1, Reverse.");
        digitalWrite(m1Rev, HIGH);
        m1Millis = millis();
        m1rState++;
      }
    }
    else if (serialString1[x] == '9')
    {
      if (m2rState == 0) {
        Serial.println("Command: Motor 2, Forward.");
        digitalWrite(m2Fwd, HIGH);
        m2Millis = millis();
        m2fState++;
      }
    }
    else if (serialString1[x] == '6')
    {
      if (m2fState == 0) {
        Serial.println("Command: Motor 2, Reverse.");
        digitalWrite(m2Rev, HIGH);
        m2Millis = millis();
        m2rState++;
      }
    }
    else if (serialString1[x] == '8')
    {
      if (m3rState == 0) {
        Serial.println("Command: Motor 3, Forward.");
        digitalWrite(m3Fwd, HIGH);
        m3Millis = millis();
        m3fState++;
      }
      else if (m3rState > 0) {
        Serial.println("DENIED: Motor 3, Forward.");
      }
    }
    else if (serialString1[x] == '5')
    {
      if (m3fState == 0) {
        Serial.println("Command: Motor 3, Reverse.");
        digitalWrite(m3Rev, HIGH);
        m3Millis = millis();
        m3rState++;
      }
      else if (m3fState > 0) {
        Serial.println("DENIED: Motor 3, Reverse.");
      }
    }
    else if (serialString1[x] == '+')
    {
      Serial.println("Command: Gripper, Forward.");
      digitalWrite(m4Fwd, HIGH);
      delay(gripTime);
      digitalWrite(m4Fwd, LOW);
    }
    else if (serialString1[x] == '-')
    {
      Serial.println("Command: Gripper, Reverse.");
      digitalWrite(m4Rev, HIGH);
      delay(gripTime);
      digitalWrite(m4Rev, LOW);
    }
    else if (serialString1[x] == '2')
    {
      Serial.print("Burst time was: ");
      Serial.print(burstTime);
      Serial.print(". New Burst Time: ");
      burstTime += mStep;
      Serial.print(burstTime);
      Serial.println(".");
    }
    else if (serialString1[x] == '.')
    {
      Serial.print("Burst time was: ");
      Serial.print(burstTime);
      Serial.print(". New Burst Time: ");
      burstTime -= mStep;
      Serial.print(burstTime);
      Serial.println(".");
    }
    else if (serialString1[x] == 'z')
    {
      if ((lWmRState == 0) && (rWmFState == 0)) {
        Serial.println("Command: spin, Left.");
        digitalWrite(leftWmotorFwd, HIGH);
        digitalWrite(rightWmotorRev, HIGH);
        lWmFMillis = millis();
        rWmRMillis = millis();
        lWmFState++;
        rWmRState++;
      }
    }
    else if (serialString1[x] == 'c')
    {
      if ((lWmRState == 0) && (rWmFState == 0)) {
        Serial.println("Command: spin, Right.");
        digitalWrite(leftWmotorRev, HIGH);
        digitalWrite(rightWmotorFwd, HIGH);
        lWmRMillis = millis();
        rWmFMillis = millis();
        lWmRState++;
        rWmFState++;
      }
    }
    else if (serialString1[x] == 'x')
    {
      Serial.println("Command: spin, 180.");
      spin180r();
    }
  }
}
